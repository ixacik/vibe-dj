import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface PromptGroup {
  id: string;
  summary: string;
  createdAt: number;
  trackIds: string[];
  isAutoGenerated: boolean;
}

interface PromptGroupsStore {
  // All prompt groups
  promptGroups: Record<string, PromptGroup>;

  // Currently playing prompt group ID
  activeGroupId: string | null;

  // Create a new prompt group
  createPromptGroup: (summary: string, trackIds: string[], isAutoGenerated?: boolean) => string;

  // Add tracks to existing group
  addTracksToGroup: (groupId: string, trackIds: string[]) => void;

  // Set active group when track starts playing
  setActiveGroup: (groupId: string | null) => void;

  // Get prompt group for a track
  getTrackPromptGroup: (trackId: string) => PromptGroup | null;

  // Remove track from groups (when played/skipped)
  removeTrackFromGroups: (trackId: string) => void;

  // Clean up empty groups
  cleanupEmptyGroups: () => void;
}

export const usePromptGroupsStore = create<PromptGroupsStore>()(
  persist(
    (set, get) => ({
      promptGroups: {},
      activeGroupId: null,

      createPromptGroup: (summary, trackIds, isAutoGenerated = false) => {
        const groupId = `prompt-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

        set((state) => ({
          promptGroups: {
            ...state.promptGroups,
            [groupId]: {
              id: groupId,
              summary,
              createdAt: Date.now(),
              trackIds,
              isAutoGenerated: isAutoGenerated,
            },
          },
        }));

        return groupId;
      },

      addTracksToGroup: (groupId, trackIds) => {
        set((state) => {
          const group = state.promptGroups[groupId];
          if (!group) return state;

          return {
            promptGroups: {
              ...state.promptGroups,
              [groupId]: {
                ...group,
                trackIds: [...new Set([...group.trackIds, ...trackIds])],
              },
            },
          };
        });
      },

      setActiveGroup: (groupId) => {
        set({ activeGroupId: groupId });
      },

      getTrackPromptGroup: (trackId) => {
        const groups = get().promptGroups;
        for (const group of Object.values(groups)) {
          if (group.trackIds.includes(trackId)) {
            return group;
          }
        }
        return null;
      },

      removeTrackFromGroups: (trackId) => {
        set((state) => {
          const updatedGroups = { ...state.promptGroups };

          for (const groupId in updatedGroups) {
            const group = updatedGroups[groupId];
            const filteredTrackIds = group.trackIds.filter(id => id !== trackId);

            if (filteredTrackIds.length !== group.trackIds.length) {
              updatedGroups[groupId] = {
                ...group,
                trackIds: filteredTrackIds,
              };
            }
          }

          return { promptGroups: updatedGroups };
        });
      },

      cleanupEmptyGroups: () => {
        set((state) => {
          const updatedGroups = { ...state.promptGroups };
          const oneHourAgo = Date.now() - 60 * 60 * 1000;

          for (const groupId in updatedGroups) {
            const group = updatedGroups[groupId];
            // Remove groups that are empty AND older than 1 hour
            if (group.trackIds.length === 0 && group.createdAt < oneHourAgo) {
              delete updatedGroups[groupId];
            }
          }

          return { promptGroups: updatedGroups };
        });
      },
    }),
    {
      name: 'vibe-dj-prompt-groups',
    }
  )
);