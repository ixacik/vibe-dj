import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface PromptContext {
  promptId: string;
  summary: string;
  createdAt: number;
  isAutoGenerated: boolean;
}

interface PromptContextStore {
  // Map of trackId -> promptContext (using object for persistence)
  trackContexts: Record<string, PromptContext>;

  // Currently displaying prompt ID (for UI)
  displayingPromptId: string | null;

  // Assign context to multiple tracks
  assignContext: (trackIds: string[], promptId: string, summary: string, isAutoGenerated?: boolean) => void;

  // Track lifecycle events
  onTrackStarted: (trackId: string) => void;
  onTrackEnded: (trackId: string) => void;

  // Get context for a specific track
  getTrackContext: (trackId: string) => PromptContext | null;

  // Get the currently active prompt (based on displaying prompt)
  getActivePrompt: () => PromptContext | null;

  // Garbage collect contexts for tracks not in queue
  garbageCollect: (queueTrackIds: string[], currentlyPlayingId: string | null) => void;

  // Clear all contexts
  clearAll: () => void;
}

export const usePromptContextStore = create<PromptContextStore>()(
  persist(
    (set, get) => ({
      trackContexts: {},
      displayingPromptId: null,

      assignContext: (trackIds, promptId, summary, isAutoGenerated = false) => {
        const context: PromptContext = {
          promptId,
          summary,
          createdAt: Date.now(),
          isAutoGenerated,
        };

        set((state) => {
          const newContexts = { ...state.trackContexts };
          trackIds.forEach(trackId => {
            newContexts[trackId] = context;
          });
          return { trackContexts: newContexts };
        });
      },

      onTrackStarted: (trackId) => {
        const context = get().trackContexts[trackId];
        if (context) {
          set({ displayingPromptId: context.promptId });
        } else {
          set({ displayingPromptId: null });
        }
      },

      onTrackEnded: (trackId) => {
        set((state) => {
          const newContexts = { ...state.trackContexts };
          delete newContexts[trackId];

          // Clear display if this was the last track with this prompt
          const context = state.trackContexts[trackId];
          if (context && state.displayingPromptId === context.promptId) {
            const hasOtherTracksWithSamePrompt = Object.values(newContexts)
              .some(c => c.promptId === context.promptId);

            if (!hasOtherTracksWithSamePrompt) {
              return {
                trackContexts: newContexts,
                displayingPromptId: null
              };
            }
          }

          return { trackContexts: newContexts };
        });
      },

      getTrackContext: (trackId) => {
        return get().trackContexts[trackId] || null;
      },

      getActivePrompt: () => {
        const state = get();
        if (!state.displayingPromptId) return null;

        // Find any context with the displaying prompt ID
        const context = Object.values(state.trackContexts)
          .find(c => c.promptId === state.displayingPromptId);

        return context || null;
      },

      garbageCollect: (queueTrackIds, currentlyPlayingId) => {
        set((state) => {
          const queueSet = new Set(queueTrackIds);
          const newContexts: Record<string, PromptContext> = {};

          // Keep only tracks that are either playing or in queue
          Object.entries(state.trackContexts).forEach(([trackId, context]) => {
            if (trackId === currentlyPlayingId || queueSet.has(trackId)) {
              newContexts[trackId] = context;
            }
          });

          // Update display if active prompt was removed
          if (state.displayingPromptId) {
            const stillHasPrompt = Object.values(newContexts)
              .some(c => c.promptId === state.displayingPromptId);

            if (!stillHasPrompt) {
              return {
                trackContexts: newContexts,
                displayingPromptId: null
              };
            }
          }

          return { trackContexts: newContexts };
        });
      },

      clearAll: () => {
        set({
          trackContexts: {},
          displayingPromptId: null
        });
      },
    }),
    {
      name: 'vibe-dj-prompt-context',
    }
  )
);